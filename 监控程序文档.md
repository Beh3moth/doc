# 监控程序文档

本监控程序面向RV64I指令集的CPU，由32位的监控程序修改而成。

????????????????????????/我这边的monitor.c可能比较旧了，至少我感觉print_hex应该参数是unsigned long long……但我这边现在不是

？？？？？？然后你可以补充一下每条指令的格式和输出样例

## 文件结构

* Makefile：运行make之后生成监控程序的二进制文件monitor.bin，以及与之相对应的汇编文件disas.S。在Makefile中，我们提供了一个CFLAGS选项，在这个选项中允许使用监控程序的用户自由选择是否开启CSR、中断、IRQ和ECALL。同时，在START_ADR和VA_BASE中规定了？？？？？？？？？？？？？？？？？？？？。
* monitor.c：监控程序的主程序，用C代码写成。
* entry.S：用来控制中断的汇编程序。

## 使用方法

### 测试环境

在运行本监控程序时，完成初始化，大概需要？？？？个周期。在虚拟测试环境下，应当适当增加周期数，以执行输入的指令。

本监控程序通过串口输入输出执行命令和打印结果。串口的地址定义在arch.h中。

### 初始化

监控程序打开后，如果初始化没有问题，会进入monitor.c中的start函数，输出“Welcome to System on Cat!”等信息。注意print函数需要比较多的周期来执行，在虚拟测试环境下为简单起见可以注释掉一些输出信息。

### 时钟中断

如果打开了CSR和中断，在初始化的输出结束之后，监控程序会定时地生成时钟中断。时钟中断可能在流水线的任何状态下被触发。中断的相关信息在init函数中被初始化。

中断初始化之后，进入无限循环。这时会打印三个小于号，然后等待用户从串口输入指令（以回车结尾）。

### J指令

J指令表示跳转到一个指定的地址：

```
>>> J 0xC0020000
```

跳转到的地址被我们的监控程序认为是一个“用户程序”，当执行ret语句的时候，跳转回主程序的循环中。

### R指令

R指令表示查看寄存器：

```
>>> R
```

执行后，输出每个寄存器的值。

### E指令

E指令表示编辑数据：

```
>>> E 0xc0020000
```

执行后，进入编辑数据状态，每次输入4个字节的数据（16进制）并回车。编辑结束时，不输入任何字符直接回车。

### I指令

I指令表示编辑指令：

```
>>> E 0xc0020000
```

执行后，进入编辑数据状态，每次输入一条指令（数字用16进制表示）并回车。编辑结束时，不输入任何字符直接回车。

### V指令

V指令表示查看数据：

```
>>> V 0xc0020000 0x10
```

执行后，输出从指定的起始地址开始、指定字节数的数据。

### D指令

V指令表示查看指令：

```
>>> D 0xc0020000 0x10
```

执行后，输出从指定的起始地址开始、指定字节数的指令（即将数据翻译成汇编指令）。

### T指令

T指令表示设置用户程序执行时间指令：

```
>>> T 0x00100000
```

J指令跳转到的用户程序会进行时间计数，当用户程序达到指定的时间时，会在时钟中断里自动跳出。

### H指令

H指令表示查看帮助。

```
>>> H
```

执行之后，输出帮助。

